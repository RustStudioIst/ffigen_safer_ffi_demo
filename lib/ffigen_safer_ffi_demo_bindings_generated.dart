// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `src/ffigen_safer_ffi_demo.h`.
///
/// Regenerate bindings with `flutter pub run ffigen --config ffigen.yaml`.
///
class FfigenSaferFfiDemoBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FfigenSaferFfiDemoBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FfigenSaferFfiDemoBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// \brief
  /// Returns the middle point of `[a, b]`.
  Point_t mid_point(
    ffi.Pointer<Point_t> a,
    ffi.Pointer<Point_t> b,
  ) {
    return _mid_point(
      a,
      b,
    );
  }

  late final _mid_pointPtr = _lookup<
      ffi.NativeFunction<
          Point_t Function(
              ffi.Pointer<Point_t>, ffi.Pointer<Point_t>)>>('mid_point');
  late final _mid_point = _mid_pointPtr.asFunction<
      Point_t Function(ffi.Pointer<Point_t>, ffi.Pointer<Point_t>)>();

  /// \brief
  /// Pretty-prints a point using Rust's formatting logic.
  void print_point(
    ffi.Pointer<Point_t> point,
  ) {
    return _print_point(
      point,
    );
  }

  late final _print_pointPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Point_t>)>>(
          'print_point');
  late final _print_point =
      _print_pointPtr.asFunction<void Function(ffi.Pointer<Point_t>)>();

  /// \brief
  /// 测试输入一个字节数组, 返回对应的字节长度
  int test_bytes(
    ffi.Pointer<Vec_uint8_t> bytes,
  ) {
    return _test_bytes(
      bytes,
    );
  }

  late final _test_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<Vec_uint8_t>)>>(
          'test_bytes');
  late final _test_bytes =
      _test_bytesPtr.asFunction<int Function(ffi.Pointer<Vec_uint8_t>)>();

  /// \brief
  ///
  /// @author <a href="mailto:angcyo@126.com">angcyo</a>
  /// @date 2024/04/30
  ///
  /// 测试输入一个字符串, 返回对应的字符串
  Vec_uint8_t test_string(
    ffi.Pointer<Vec_uint8_t> str,
  ) {
    return _test_string(
      str,
    );
  }

  late final _test_stringPtr = _lookup<
          ffi.NativeFunction<Vec_uint8_t Function(ffi.Pointer<Vec_uint8_t>)>>(
      'test_string');
  late final _test_string = _test_stringPtr
      .asFunction<Vec_uint8_t Function(ffi.Pointer<Vec_uint8_t>)>();
}

/// \brief
/// A `struct` usable from both Rust and C
final class Point extends ffi.Struct {
  /// <No documentation available>
  @ffi.Double()
  external double x;

  /// <No documentation available>
  @ffi.Double()
  external double y;
}

/// \brief
/// A `struct` usable from both Rust and C
typedef Point_t = Point;

/// \brief
/// Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
final class Vec_uint8 extends ffi.Struct {
  /// <No documentation available>
  external ffi.Pointer<ffi.Uint8> ptr;

  /// <No documentation available>
  @ffi.Size()
  external int len;

  /// <No documentation available>
  @ffi.Size()
  external int cap;
}

/// \brief
/// Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
typedef Vec_uint8_t = Vec_uint8;
